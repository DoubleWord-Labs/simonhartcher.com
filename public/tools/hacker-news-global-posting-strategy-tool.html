<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hacker News Global Posting Times Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .subtitle {
            font-size: 1.1em;
            opacity: 0.95;
            margin-bottom: 20px;
        }
        
        .control-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: space-between;
        }
        
        .tz-selector {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
            min-width: 300px;
        }
        
        .tz-selector label {
            font-weight: 600;
            color: #555;
        }
        
        select {
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 250px;
        }
        
        select:hover {
            border-color: #667eea;
        }
        
        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .info-badges {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .badge {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.4em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .card-subtitle {
            font-size: 0.6em;
            color: #666;
            font-weight: normal;
        }
        
        .heatmap-container {
            grid-column: span 2;
            overflow-x: auto;
        }
        
        .heatmap-wrapper {
            min-width: 900px;
        }
        
        .heatmap {
            display: grid;
            grid-template-columns: 80px repeat(24, 1fr);
            gap: 2px;
            margin-bottom: 15px;
        }
        
        .heatmap-cell {
            padding: 10px 4px;
            text-align: center;
            font-size: 0.75em;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .heatmap-cell:hover {
            transform: scale(1.15);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .day-label {
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: right;
            padding-right: 10px;
            color: #555;
            font-size: 0.9em;
        }
        
        .hour-label {
            font-weight: 600;
            color: #666;
            font-size: 0.85em;
        }
        
        .heat-0 { background: #f5f5f5; color: #bbb; }
        .heat-1 { background: #ffebee; color: #888; }
        .heat-2 { background: #ffcdd2; color: #666; }
        .heat-3 { background: #ef9a9a; color: #333; }
        .heat-4 { background: #e57373; color: #000; }
        .heat-5 { background: #ef5350; color: #fff; }
        .heat-6 { background: #f44336; color: #fff; }
        .heat-7 { background: #66bb6a; color: #fff; font-weight: bold; }
        .heat-8 { background: #4caf50; color: #fff; font-weight: bold; }
        .heat-9 { background: #2e7d32; color: #fff; font-weight: bold; }
        
        .optimal-cell {
            animation: pulse 2s infinite;
            border: 2px solid gold !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6) !important;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
            100% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .auto-detected {
            animation: fadeIn 0.5s ease-out;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
        }
        
        .legend-box {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .insights {
            background: linear-gradient(135deg, #4caf50, #2e7d32);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .insights h2 {
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        
        .insight-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .insight-item {
            background: rgba(255,255,255,0.15);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .insight-time {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .insight-desc {
            font-size: 0.9em;
            opacity: 0.95;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.85em;
            opacity: 0.9;
        }
        
        canvas {
            max-height: 350px;
        }
        
        .debug-info {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.85em;
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .heatmap-container {
                grid-column: span 1;
            }
            
            .control-panel {
                flex-direction: column;
                align-items: stretch;
            }
            
            .tz-selector {
                flex-direction: column;
                align-items: stretch;
            }
            
            select {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üåç Hacker News Global Posting Strategy</h1>
            <p class="subtitle">Data-driven posting times optimized for your timezone</p>
        </header>
        
        <div class="control-panel">
            <div class="tz-selector">
                <label for="timezone">Your Location:</label>
                <select id="timezone">
                    <optgroup label="Americas">
                        <option value="-8">San Francisco (PST, UTC-8)</option>
                        <option value="-7">San Francisco Summer (PDT, UTC-7)</option>
                        <option value="-5">New York (EST, UTC-5)</option>
                        <option value="-4">New York Summer (EDT, UTC-4)</option>
                        <option value="-6">Austin/Chicago (CST, UTC-6)</option>
                        <option value="-5">Chicago Summer (CDT, UTC-5)</option>
                        <option value="-7">Denver/Phoenix (MST, UTC-7)</option>
                        <option value="-3">S√£o Paulo (BRT, UTC-3)</option>
                        <option value="-8">Vancouver (PST, UTC-8)</option>
                        <option value="-7">Vancouver Summer (PDT, UTC-7)</option>
                        <option value="-5">Toronto (EST, UTC-5)</option>
                        <option value="-4">Toronto Summer (EDT, UTC-4)</option>
                    </optgroup>
                    <optgroup label="Europe">
                        <option value="0">London Winter (GMT, UTC+0)</option>
                        <option value="1">London Summer (BST, UTC+1)</option>
                        <option value="1">Berlin/Paris Winter (CET, UTC+1)</option>
                        <option value="2">Berlin/Paris Summer (CEST, UTC+2)</option>
                        <option value="1">Amsterdam Winter (CET, UTC+1)</option>
                        <option value="2">Amsterdam Summer (CEST, UTC+2)</option>
                        <option value="2">Stockholm/Oslo (EET, UTC+2)</option>
                        <option value="3">Moscow (MSK, UTC+3)</option>
                        <option value="0">Dublin Winter (GMT, UTC+0)</option>
                        <option value="1">Dublin Summer (IST, UTC+1)</option>
                    </optgroup>
                    <optgroup label="Middle East & Africa">
                        <option value="2">Tel Aviv (IST, UTC+2)</option>
                        <option value="4">Dubai (GST, UTC+4)</option>
                        <option value="2">Cape Town (SAST, UTC+2)</option>
                        <option value="3">Nairobi (EAT, UTC+3)</option>
                    </optgroup>
                    <optgroup label="Asia">
                        <option value="5.5">Bangalore/Mumbai (IST, UTC+5:30)</option>
                        <option value="8">Singapore/Beijing (SGT, UTC+8)</option>
                        <option value="8">Hong Kong (HKT, UTC+8)</option>
                        <option value="9">Tokyo (JST, UTC+9)</option>
                        <option value="9">Seoul (KST, UTC+9)</option>
                        <option value="7">Bangkok/Jakarta (WIB, UTC+7)</option>
                    </optgroup>
                    <optgroup label="Oceania">
                        <option value="11" selected>Sydney/Melbourne (AEDT, UTC+11)</option>
                        <option value="10">Sydney Winter (AEST, UTC+10)</option>
                        <option value="10">Brisbane (AEST, UTC+10)</option>
                        <option value="13">Auckland (NZDT, UTC+13)</option>
                        <option value="8">Perth (AWST, UTC+8)</option>
                    </optgroup>
                </select>
            </div>
            
            <div class="info-badges">
                <div class="badge" id="current-time">Loading...</div>
                <div class="badge" id="sf-time">SF: Loading...</div>
                <div class="badge" id="best-window">Best: Loading...</div>
            </div>
        </div>
        
        <div class="insights" id="insights">
            <h2>üìä Optimal Posting Strategy</h2>
            <div class="insight-grid" id="insight-grid">
                <!-- Dynamically populated -->
            </div>
        </div>
        
        <!-- Debug info - remove in production -->
        <div class="debug-info" id="debug-info" style="display: none;">
            Debug info will appear here
        </div>
        
        <div class="dashboard">
            <div class="card heatmap-container">
                <h2>
                    Success Rate Heatmap
                    <span class="card-subtitle" id="heatmap-subtitle">Your Local Time</span>
                </h2>
                <div class="heatmap-wrapper">
                    <div id="heatmap" class="heatmap"></div>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-box heat-1"></div>
                        <span>Very Low</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box heat-3"></div>
                        <span>Low</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box heat-5"></div>
                        <span>Medium</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box heat-7"></div>
                        <span>High</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box heat-9"></div>
                        <span>Peak</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box optimal-cell" style="width: 24px; height: 24px;"></div>
                        <span>Your Best Time</span>
                    </div>
                </div>
            </div>
            
            <div class="card" id="bestWindowsCard">
                <h2>Top 10 Posting Opportunities</h2>
                <canvas id="bestWindowsChart"></canvas>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="optimal-time">Loading...</div>
                        <div class="stat-label">Best Time</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="success-multi">Loading...</div>
                        <div class="stat-label">vs Average</div>
                    </div>
                </div>
            </div>
            
            <div class="card" id="trafficCard">
                <h2>Expected Traffic (If Front Page)</h2>
                <canvas id="trafficChart"></canvas>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="peak-traffic">75K</div>
                        <div class="stat-label">Peak Traffic</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="off-peak">30K</div>
                        <div class="stat-label">Off-Peak</div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2>Competition Level by Day</h2>
                <canvas id="competitionChart"></canvas>
            </div>
            
            <div class="card">
                <h2>
                    Engagement Patterns
                    <select id="engagement-day" style="font-size: 0.7em; padding: 4px 8px; margin-left: 10px;">
                        <option value="average">Weekly Average</option>
                        <option value="Sunday">Sunday</option>
                        <option value="Monday">Monday</option>
                        <option value="Tuesday">Tuesday</option>
                        <option value="Wednesday">Wednesday</option>
                        <option value="Thursday">Thursday</option>
                        <option value="Friday">Friday</option>
                        <option value="Saturday">Saturday</option>
                    </select>
                </h2>
                <canvas id="engagementChart"></canvas>
            </div>
            
            <div class="card">
                <h2>Strategic Guidelines</h2>
                <div style="padding: 10px; line-height: 1.8;">
                    <h3 style="color: #4caf50; margin-bottom: 10px;">‚úÖ Success Factors</h3>
                    <ul style="margin-left: 25px; margin-bottom: 20px;">
                        <li>First 10 minutes determine trajectory</li>
                        <li>5-6 quick upvotes needed to reach page 2</li>
                        <li>Comments > upvotes for ranking</li>
                        <li>Author engagement crucial for 6-13 hours</li>
                    </ul>
                    
                    <h3 style="color: #ff9800; margin-bottom: 10px;">‚ö†Ô∏è Avoid These Mistakes</h3>
                    <ul style="margin-left: 25px; margin-bottom: 20px;">
                        <li>Never ask colleagues for upvotes</li>
                        <li>Don't use marketing language</li>
                        <li>Avoid posting on Fridays after 2 PM PST</li>
                        <li>Don't delete if not immediately successful</li>
                    </ul>
                    
                    <h3 style="color: #2196f3; margin-bottom: 10px;">üí° Content Tips</h3>
                    <ul style="margin-left: 25px;">
                        <li>Technical depth beats broad overviews</li>
                        <li>"Show HN" for tools/demos</li>
                        <li>Include code/data/benchmarks</li>
                        <li>Lead with value, not your company</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Single source of truth - PST base data
        const baseData = {
            timezone: 'PST',
            utcOffset: -8,
            successRates: {
                'Sunday': [4,4,3,3,4,5,7,8,8,7,5,4,4,3,3,3,3,4,4,3,3,3,3,3],
                'Monday': [3,3,3,4,5,6,8,9,9,8,7,6,5,4,4,3,3,3,3,3,2,2,2,2],
                'Tuesday': [2,2,2,3,4,5,8,9,9,9,8,7,6,5,4,3,3,3,3,2,2,2,2,2],
                'Wednesday': [2,2,2,3,4,5,8,9,9,9,8,7,6,5,4,3,3,3,3,2,2,2,2,2],
                'Thursday': [2,2,2,3,4,5,7,8,9,9,8,7,6,5,4,3,3,3,3,2,2,2,2,2],
                'Friday': [2,2,2,3,4,5,6,7,7,6,5,4,3,2,2,1,1,1,1,1,1,1,1,1],
                'Saturday': [1,1,1,1,2,2,3,3,3,3,3,2,2,2,1,1,1,1,1,1,1,1,1,1]
            }
        };
        
        let currentTimezoneOffset = 11; // Default to Sydney AEDT
        let charts = {};
        
        // Fixed timezone conversion function
        function getTimezoneData(targetOffset) {
            const sourceOffset = baseData.utcOffset; // -8 for PST
            const hourShift = targetOffset - sourceOffset;
            
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const result = {};
            
            // Initialize result
            days.forEach(day => {
                result[day] = new Array(24).fill(0);
            });
            
            // Handle fractional offsets
            const isFractional = hourShift % 1 !== 0;
            
            // For each day and hour in source data
            days.forEach((day, dayIdx) => {
                baseData.successRates[day].forEach((value, hour) => {
                    if (isFractional) {
                        // For half-hour offsets, we need special handling
                        // We'll use the maximum value approach to avoid zeros
                        const newTime = hour + hourShift;
                        const newHour = Math.floor(newTime);
                        
                        // Calculate which day this falls into
                        let targetHour = newHour;
                        let dayOffset = 0;
                        
                        while (targetHour >= 24) {
                            targetHour -= 24;
                            dayOffset++;
                        }
                        while (targetHour < 0) {
                            targetHour += 24;
                            dayOffset--;
                        }
                        
                        let targetDayIdx = (dayIdx + dayOffset + 700) % 7; // +700 to ensure positive
                        const targetDay = days[targetDayIdx];
                        
                        // For fractional offsets, apply value to current and next hour
                        result[targetDay][targetHour] = Math.max(result[targetDay][targetHour], value);
                        
                        // Also apply to next hour for smoothing
                        const nextHour = (targetHour + 1) % 24;
                        if (nextHour === 0) {
                            const nextDayIdx = (targetDayIdx + 1) % 7;
                            const nextDay = days[nextDayIdx];
                            result[nextDay][nextHour] = Math.max(result[nextDay][nextHour], value);
                        } else {
                            result[targetDay][nextHour] = Math.max(result[targetDay][nextHour], value);
                        }
                    } else {
                        // Integer hour shift - simple case
                        let newHour = hour + Math.round(hourShift);
                        let dayOffset = 0;
                        
                        while (newHour >= 24) {
                            newHour -= 24;
                            dayOffset++;
                        }
                        while (newHour < 0) {
                            newHour += 24;
                            dayOffset--;
                        }
                        
                        let newDayIdx = (dayIdx + dayOffset + 700) % 7; // +700 to ensure positive
                        const newDay = days[newDayIdx];
                        
                        result[newDay][newHour] = value;
                    }
                });
            });
            
            return result;
        }
        
        function getEngagementData(timezoneOffset, selectedDay = 'average') {
            const data = getTimezoneData(timezoneOffset);
            
            if (selectedDay === 'average') {
                // Calculate average across all days
                const hourlyAvg = new Array(24).fill(0);
                Object.values(data).forEach(dayData => {
                    dayData.forEach((value, hour) => {
                        hourlyAvg[hour] += value / 7;
                    });
                });
                return hourlyAvg;
            } else {
                // Return specific day's data
                return data[selectedDay] || new Array(24).fill(0);
            }
        }
        
        function updateEngagementChart() {
            if (!charts.engagement) return;
            
            const selectedDay = document.getElementById('engagement-day').value;
            const engagementData = getEngagementData(currentTimezoneOffset, selectedDay);
            
            charts.engagement.data.datasets[0].data = engagementData;
            
            // Update chart styling based on selection
            if (selectedDay === 'average') {
                charts.engagement.data.datasets[0].borderColor = '#9c27b0';
                charts.engagement.data.datasets[0].backgroundColor = 'rgba(156, 39, 176, 0.1)';
            } else if (selectedDay === 'Sunday') {
                charts.engagement.data.datasets[0].borderColor = '#4caf50';
                charts.engagement.data.datasets[0].backgroundColor = 'rgba(76, 175, 80, 0.1)';
            } else if (selectedDay === 'Saturday') {
                charts.engagement.data.datasets[0].borderColor = '#f44336';
                charts.engagement.data.datasets[0].backgroundColor = 'rgba(244, 67, 54, 0.1)';
            } else {
                charts.engagement.data.datasets[0].borderColor = '#2196f3';
                charts.engagement.data.datasets[0].backgroundColor = 'rgba(33, 150, 243, 0.1)';
            }
            
            charts.engagement.update();
        }
        
        function getTrafficEstimates(timezoneOffset) {
            const data = getTimezoneData(timezoneOffset);
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            return days.map(day => {
                const maxScore = Math.max(...data[day]);
                return Math.round(maxScore * 8.3); // Scale to traffic estimate
            });
        }
        
        function getCompetitionLevels(timezoneOffset) {
            const data = getTimezoneData(timezoneOffset);
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            return days.map(day => {
                const goodHours = data[day].filter(h => h >= 6).length;
                return goodHours === 0 ? 0.1 : (10 - goodHours) / 10;
            });
        }
        
        function getBestWindows(timezoneOffset) {
            const data = getTimezoneData(timezoneOffset);
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const windows = [];
            
            // Find all windows with their scores
            days.forEach(day => {
                data[day].forEach((score, hour) => {
                    windows.push({
                        day: day,
                        hour: hour,
                        score: score,
                        dayShort: day.substring(0, 3),
                        label: `${day.substring(0, 3)} ${formatHour(hour)}`,
                        // Apply Sunday bonus to score
                        adjustedScore: day === 'Sunday' ? score * 2.5 : score
                    });
                });
            });
            
            // Sort by adjusted score and get top windows
            windows.sort((a, b) => b.adjustedScore - a.adjustedScore);
            
            // Get top 10 windows
            const topWindows = windows.slice(0, 10);
            
            // Also calculate metrics for viable hours (6 AM - 10 PM)
            const viableWindows = windows.filter(w => w.hour >= 6 && w.hour <= 22);
            const bestViable = viableWindows.reduce((best, w) => 
                w.adjustedScore > best.adjustedScore ? w : best, viableWindows[0]);
            
            return { topWindows, bestViable, allWindows: windows };
        }
        
        function findOptimalTimes(data) {
            const times = [];
            const days = Object.keys(data);
            
            days.forEach(day => {
                data[day].forEach((value, hour) => {
                    times.push({
                        day,
                        hour,
                        value,
                        score: value * (day === 'Sunday' ? 2.5 : 1) // Sunday bonus
                    });
                });
            });
            
            times.sort((a, b) => b.score - a.score);
            
            // Get top 3 unique time windows
            const optimal = [];
            const seen = new Set();
            
            for (const time of times) {
                const key = `${time.day}-${Math.floor(time.hour / 3)}`; // Group by 3-hour windows
                if (!seen.has(key) && optimal.length < 3) {
                    seen.add(key);
                    optimal.push(time);
                }
            }
            
            return optimal;
        }
        
        function formatHour(hour) {
            const period = hour >= 12 ? 'PM' : 'AM';
            const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
            return `${displayHour}:00 ${period}`;
        }
        
        function updateClock() {
            const now = new Date();
            const localTime = now.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: true 
            });
            
            // Calculate SF time
            const sfOffset = -8;
            const utcTime = now.getTime() + (now.getTimezoneOffset() * 60000);
            const sfTime = new Date(utcTime + (3600000 * sfOffset));
            const sfTimeStr = sfTime.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: true 
            });
            
            document.getElementById('current-time').textContent = `Local: ${localTime}`;
            document.getElementById('sf-time').textContent = `SF: ${sfTimeStr}`;
        }
        
        function createHeatmap() {
            const heatmapDiv = document.getElementById('heatmap');
            heatmapDiv.innerHTML = '';
            
            const data = getTimezoneData(currentTimezoneOffset);
            const optimal = findOptimalTimes(data);
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            
            // Add corner cell
            heatmapDiv.appendChild(document.createElement('div'));
            
            // Add hour labels
            for (let hour = 0; hour < 24; hour++) {
                const label = document.createElement('div');
                label.className = 'heatmap-cell hour-label';
                label.textContent = formatHour(hour);
                heatmapDiv.appendChild(label);
            }
            
            // Add day rows
            days.forEach(day => {
                const dayLabel = document.createElement('div');
                dayLabel.className = 'day-label';
                dayLabel.textContent = day;
                heatmapDiv.appendChild(dayLabel);
                
                data[day].forEach((value, hour) => {
                    const cell = document.createElement('div');
                    cell.className = `heatmap-cell heat-${Math.round(value)}`;
                    
                    // Check if this is an optimal time
                    const isOptimal = optimal[0] && optimal[0].day === day && 
                                    Math.abs(optimal[0].hour - hour) <= 1;
                    
                    if (isOptimal) {
                        cell.classList.add('optimal-cell');
                        cell.innerHTML = 'üèÜ';
                    } else if (value >= 8) {
                        cell.innerHTML = '‚òÖ';
                    } else if (value >= 6) {
                        cell.innerHTML = '‚Ä¢';
                    }
                    
                    // Tooltip
                    cell.title = `${day} ${formatHour(hour)} - Success level: ${value}/10`;
                    if (isOptimal) {
                        cell.title += ' - OPTIMAL TIME!';
                    }
                    
                    heatmapDiv.appendChild(cell);
                });
            });
        }
        
        function updateInsights() {
            const data = getTimezoneData(currentTimezoneOffset);
            const optimal = findOptimalTimes(data);
            const insightGrid = document.getElementById('insight-grid');
            
            insightGrid.innerHTML = '';
            
            if (optimal.length > 0) {
                // Best overall time
                const best = optimal[0];
                insightGrid.innerHTML += `
                    <div class="insight-item">
                        <div class="insight-time">ü•á ${best.day} ${formatHour(best.hour)}</div>
                        <div class="insight-desc">Highest success probability (${(best.score/4).toFixed(1)}x baseline)</div>
                    </div>
                `;
                
                // Update best window badge
                document.getElementById('best-window').textContent = 
                    `Best: ${best.day.substring(0, 3)} ${formatHour(best.hour)}`;
            }
            
            // Second best
            if (optimal[1]) {
                insightGrid.innerHTML += `
                    <div class="insight-item">
                        <div class="insight-time">ü•à ${optimal[1].day} ${formatHour(optimal[1].hour)}</div>
                        <div class="insight-desc">Strong alternative window</div>
                    </div>
                `;
            }
            
            // Best weekday
            const weekdayOptimal = optimal.find(t => !['Saturday', 'Sunday'].includes(t.day));
            if (weekdayOptimal) {
                insightGrid.innerHTML += `
                    <div class="insight-item">
                        <div class="insight-time">üíº ${weekdayOptimal.day} ${formatHour(weekdayOptimal.hour)}</div>
                        <div class="insight-desc">Best weekday option</div>
                    </div>
                `;
            }
        }
        
        function initCharts() {
            const { topWindows, bestViable } = getBestWindows(currentTimezoneOffset);
            
            // Best Windows chart - showing top 10 posting times
            const windowsCtx = document.getElementById('bestWindowsChart').getContext('2d');
            charts.windows = new Chart(windowsCtx, {
                type: 'bar',
                data: {
                    labels: topWindows.map(w => w.label),
                    datasets: [{
                        label: 'Opportunity Score',
                        data: topWindows.map(w => w.adjustedScore.toFixed(1)),
                        backgroundColor: topWindows.map(w => {
                            if (w.adjustedScore >= 15) return '#2e7d32';
                            if (w.adjustedScore >= 10) return '#4caf50';
                            if (w.adjustedScore >= 7) return '#66bb6a';
                            if (w.adjustedScore >= 5) return '#ffa726';
                            return '#ef5350';
                        }),
                        borderRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y', // Horizontal bars
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const window = topWindows[context.dataIndex];
                                    return [
                                        `Score: ${context.parsed.x}`,
                                        `Base score: ${window.score}`,
                                        window.day === 'Sunday' ? '(Sunday 2.5x bonus applied)' : ''
                                    ].filter(Boolean);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            max: 25,
                            title: {
                                display: true,
                                text: 'Opportunity Score (higher = better)'
                            }
                        }
                    }
                }
            });
            
            // Update stat boxes
            if (bestViable) {
                document.getElementById('optimal-time').textContent = 
                    `${bestViable.dayShort} ${formatHour(bestViable.hour)}`;
                document.getElementById('success-multi').textContent = 
                    `${(bestViable.adjustedScore / 3).toFixed(1)}x`;
            }
            
            // Traffic chart remains the same but uses different data
            const trafficData = getTrafficEstimates(currentTimezoneOffset);
            const trafficCtx = document.getElementById('trafficChart').getContext('2d');
            charts.traffic = new Chart(trafficCtx, {
                type: 'line',
                data: {
                    labels: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                    datasets: [{
                        label: 'Expected Traffic (K)',
                        data: trafficData,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: value => value + 'K'
                            }
                        }
                    }
                }
            });
            
            // Competition chart
            const competitionData = getCompetitionLevels(currentTimezoneOffset);
            const competitionCtx = document.getElementById('competitionChart').getContext('2d');
            charts.competition = new Chart(competitionCtx, {
                type: 'radar',
                data: {
                    labels: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                    datasets: [{
                        label: 'Competition Level',
                        data: competitionData,
                        borderColor: '#f44336',
                        backgroundColor: 'rgba(244, 67, 54, 0.2)',
                        pointBackgroundColor: '#f44336',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: '#f44336'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 1,
                            ticks: {
                                display: false
                            }
                        }
                    }
                }
            });
            
            // Engagement patterns
            const engagementCtx = document.getElementById('engagementChart').getContext('2d');
            
            // Get initial engagement data
            const engagementData = getEngagementData(currentTimezoneOffset, 'average');
            
            charts.engagement = new Chart(engagementCtx, {
                type: 'line',
                data: {
                    labels: Array.from({length: 24}, (_, i) => formatHour(i)),
                    datasets: [{
                        label: 'Activity Level',
                        data: engagementData,
                        borderColor: '#9c27b0',
                        backgroundColor: 'rgba(156, 39, 176, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointRadius: 3,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const score = context.parsed.y.toFixed(1);
                                    const hour = context.dataIndex;
                                    return [
                                        `Score: ${score}/10`,
                                        score >= 7 ? 'Excellent time' : 
                                        score >= 5 ? 'Good time' :
                                        score >= 3 ? 'Moderate time' : 'Poor time'
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 10,
                            title: {
                                display: true,
                                text: 'Activity Score'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Hour (Local Time)'
                            }
                        }
                    }
                }
            });
        }
        
        function updateCharts() {
            const { topWindows, bestViable } = getBestWindows(currentTimezoneOffset);
            const trafficData = getTrafficEstimates(currentTimezoneOffset);
            const competitionData = getCompetitionLevels(currentTimezoneOffset);
            
            // Update best windows chart
            if (charts.windows) {
                charts.windows.data.labels = topWindows.map(w => w.label);
                charts.windows.data.datasets[0].data = topWindows.map(w => w.adjustedScore.toFixed(1));
                charts.windows.data.datasets[0].backgroundColor = topWindows.map(w => {
                    if (w.adjustedScore >= 15) return '#2e7d32';
                    if (w.adjustedScore >= 10) return '#4caf50';
                    if (w.adjustedScore >= 7) return '#66bb6a';
                    if (w.adjustedScore >= 5) return '#ffa726';
                    return '#ef5350';
                });
                charts.windows.update();
            }
            
            // Update traffic chart
            if (charts.traffic) {
                charts.traffic.data.datasets[0].data = trafficData;
                charts.traffic.update();
            }
            
            // Update competition chart
            if (charts.competition) {
                charts.competition.data.datasets[0].data = competitionData;
                charts.competition.update();
            }
            
            // Update engagement chart
            if (charts.engagement) {
                const selectedDay = document.getElementById('engagement-day').value;
                const engagementData = getEngagementData(currentTimezoneOffset, selectedDay);
                charts.engagement.data.datasets[0].data = engagementData;
                charts.engagement.data.labels = Array.from({length: 24}, (_, i) => formatHour(i));
                
                // Apply the appropriate color scheme based on selected day
                if (selectedDay === 'average') {
                    charts.engagement.data.datasets[0].borderColor = '#9c27b0';
                    charts.engagement.data.datasets[0].backgroundColor = 'rgba(156, 39, 176, 0.1)';
                } else if (selectedDay === 'Sunday') {
                    charts.engagement.data.datasets[0].borderColor = '#4caf50';
                    charts.engagement.data.datasets[0].backgroundColor = 'rgba(76, 175, 80, 0.1)';
                } else if (selectedDay === 'Saturday') {
                    charts.engagement.data.datasets[0].borderColor = '#f44336';
                    charts.engagement.data.datasets[0].backgroundColor = 'rgba(244, 67, 54, 0.1)';
                } else {
                    charts.engagement.data.datasets[0].borderColor = '#2196f3';
                    charts.engagement.data.datasets[0].backgroundColor = 'rgba(33, 150, 243, 0.1)';
                }
                
                charts.engagement.update();
            }
            
            // Update stat boxes
            const maxTraffic = Math.max(...trafficData.filter(t => t > 0));
            const minTraffic = Math.min(...trafficData.filter(t => t > 20));
            
            document.getElementById('peak-traffic').textContent = 
                isFinite(maxTraffic) ? `${maxTraffic}K` : '0K';
            document.getElementById('off-peak').textContent = 
                isFinite(minTraffic) ? `${minTraffic}K` : '0K';
            
            // Update best window stats
            if (bestViable) {
                document.getElementById('optimal-time').textContent = 
                    `${bestViable.dayShort} ${formatHour(bestViable.hour)}`;
                document.getElementById('success-multi').textContent = 
                    `${(bestViable.adjustedScore / 3).toFixed(1)}x`;
            }
        }
        
        function updateAllVisualizations() {
            createHeatmap();
            updateInsights();
            
            // Only update charts if they exist
            if (Object.keys(charts).length > 0) {
                updateCharts();
            }
            
            // Update subtitle
            const select = document.getElementById('timezone');
            const selectedText = select.options[select.selectedIndex].text;
            document.getElementById('heatmap-subtitle').textContent = 
                `Times shown in ${selectedText}`;
        }
        
        // Event listeners
        document.getElementById('timezone').addEventListener('change', (e) => {
            currentTimezoneOffset = parseFloat(e.target.value);
            updateAllVisualizations();
            updateClock();
        });
        
        // Add event listener for engagement day dropdown
        document.getElementById('engagement-day').addEventListener('change', updateEngagementChart);
        
        // Detect user's timezone from browser
        function detectUserTimezone() {
            // Get timezone offset in hours (negative of getTimezoneOffset which is in minutes)
            const offsetMinutes = new Date().getTimezoneOffset();
            const offsetHours = -offsetMinutes / 60;
            
            // Get timezone name
            const timezoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
            
            console.log(`Detected timezone: ${timezoneName} (UTC${offsetHours >= 0 ? '+' : ''}${offsetHours})`);
            
            // Find the closest option in the dropdown
            const select = document.getElementById('timezone');
            let closestOption = null;
            let closestDiff = Infinity;
            
            // First pass: try to find exact offset match with location name
            for (let option of select.options) {
                if (!option.value || option.value === '') continue; // Skip optgroup labels
                
                const optionValue = parseFloat(option.value);
                const diff = Math.abs(optionValue - offsetHours);
                
                // Exact offset match
                if (diff === 0) {
                    const optionText = option.text.toLowerCase();
                    const tzLower = timezoneName.toLowerCase();
                    
                    // Check for city/region matches
                    if (
                        (tzLower.includes('los_angeles') && optionText.includes('san francisco')) ||
                        (tzLower.includes('new_york') && optionText.includes('new york')) ||
                        (tzLower.includes('chicago') && optionText.includes('chicago')) ||
                        (tzLower.includes('denver') && optionText.includes('denver')) ||
                        (tzLower.includes('phoenix') && optionText.includes('phoenix')) ||
                        (tzLower.includes('toronto') && optionText.includes('toronto')) ||
                        (tzLower.includes('vancouver') && optionText.includes('vancouver')) ||
                        (tzLower.includes('sao_paulo') && optionText.includes('s√£o paulo')) ||
                        (tzLower.includes('london') && optionText.includes('london')) ||
                        (tzLower.includes('paris') && optionText.includes('paris')) ||
                        (tzLower.includes('berlin') && optionText.includes('berlin')) ||
                        (tzLower.includes('amsterdam') && optionText.includes('amsterdam')) ||
                        (tzLower.includes('stockholm') && optionText.includes('stockholm')) ||
                        (tzLower.includes('oslo') && optionText.includes('oslo')) ||
                        (tzLower.includes('moscow') && optionText.includes('moscow')) ||
                        (tzLower.includes('dublin') && optionText.includes('dublin')) ||
                        (tzLower.includes('jerusalem') || tzLower.includes('tel_aviv')) && optionText.includes('tel aviv') ||
                        (tzLower.includes('dubai') && optionText.includes('dubai')) ||
                        (tzLower.includes('johannesburg') || tzLower.includes('cape_town')) && optionText.includes('cape town') ||
                        (tzLower.includes('nairobi') && optionText.includes('nairobi')) ||
                        (tzLower.includes('kolkata') || tzLower.includes('mumbai') || tzLower.includes('bangalore')) && 
                            (optionText.includes('bangalore') || optionText.includes('mumbai')) ||
                        (tzLower.includes('bangkok') && optionText.includes('bangkok')) ||
                        (tzLower.includes('jakarta') && optionText.includes('jakarta')) ||
                        (tzLower.includes('singapore') && optionText.includes('singapore')) ||
                        (tzLower.includes('hong_kong') && optionText.includes('hong kong')) ||
                        (tzLower.includes('shanghai') || tzLower.includes('beijing')) && 
                            (optionText.includes('beijing') || optionText.includes('singapore')) ||
                        (tzLower.includes('tokyo') && optionText.includes('tokyo')) ||
                        (tzLower.includes('seoul') && optionText.includes('seoul')) ||
                        (tzLower.includes('sydney') && optionText.includes('sydney')) ||
                        (tzLower.includes('melbourne') && optionText.includes('melbourne')) ||
                        (tzLower.includes('brisbane') && optionText.includes('brisbane')) ||
                        (tzLower.includes('perth') && optionText.includes('perth')) ||
                        (tzLower.includes('auckland') && optionText.includes('auckland'))
                    ) {
                        closestOption = option;
                        break;
                    }
                }
            }
            
            // Second pass: if no location match, find closest offset
            if (!closestOption) {
                for (let option of select.options) {
                    if (!option.value || option.value === '') continue;
                    
                    const optionValue = parseFloat(option.value);
                    const diff = Math.abs(optionValue - offsetHours);
                    
                    if (diff < closestDiff) {
                        closestOption = option;
                        closestDiff = diff;
                    }
                }
            }
            
            // Select the detected timezone
            if (closestOption) {
                select.value = closestOption.value;
                currentTimezoneOffset = parseFloat(closestOption.value);
                
                // Add a badge to show auto-detection worked
                const badge = document.createElement('div');
                badge.className = 'badge auto-detected';
                badge.style.background = 'linear-gradient(135deg, #4caf50, #2e7d32)';
                const locationName = closestOption.text.split('(')[0].trim();
                badge.innerHTML = `‚úì Detected: ${locationName}`;
                document.querySelector('.info-badges').appendChild(badge);
                
                console.log(`Auto-selected: ${closestOption.text}`);
                
                // Remove the badge after 5 seconds
                setTimeout(() => {
                    badge.style.transition = 'opacity 0.5s';
                    badge.style.opacity = '0';
                    setTimeout(() => badge.remove(), 500);
                }, 5000);
            } else {
                console.log('Could not find matching timezone option, using default');
            }
            
            return offsetHours;
        }
        
        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            // Try to detect and set user's timezone
            try {
                detectUserTimezone();
            } catch (e) {
                console.log('Could not auto-detect timezone, using default');
                // Fall back to default (Sydney)
                currentTimezoneOffset = parseFloat(document.getElementById('timezone').value);
            }
            
            // Initialize visualizations
            updateAllVisualizations();
            initCharts();
            updateClock();
            setInterval(updateClock, 60000); // Update every minute
        });
    </script>
</body>
</html>